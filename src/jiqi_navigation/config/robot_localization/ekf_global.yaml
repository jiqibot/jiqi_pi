frequency: 30

map_frame: map
odom_frame: odom
base_link_frame: base_link
world_frame: map

two_d_mode: true # Ignores vertical component of IMU
smooth_lagged_data: true
publish_tf: true

# Wheel odometry setup
odom0: /odometry/encoder
odom0_config: [ true,  true,  false,   # [ x_pos,     y_pos,      x_pos,
                false, false, true,    #   roll,      pitch,      yaw,
                false, false, false,   #   x_vel,     y_vel,      z_vel,
                false, false, false,    #   roll_vel,  pitch_vel,  yaw_vel,
                false, false, false  ] #   x_accel,   y_accel,    z_accel  ]
odom0_queue_size: 10 # Adjust sensor callback queue sizes for each sensor - useful if frequency parameter is lower than sensor frequency, allowing filter to use all measurements between update cycles
odom0_nodelay: true # Disables Nagle's algorithm for potential lower-latency connection
odom0_differential: false # Specify whether the pose variables should be integrated differentially - if a variable (pos, vel, accel) has N sources, at least N-1 should have this enabled (most accurate sensor should be set to true if N-1)
odom0_relative: false # Sensor will be fused relative to the first measurement received - when using differential setting for angular variables this should be enabled to prevent growing without bounds.

# LiDAR (hector_mapping) setup
odom1: /scanmatch_odom
odom1_config: [ false, false, false,
                false, false, false,
                true,  true,  true,
                false, false, true,
                false, false, false  ]
odom1_queue_size: 10
odom1_nodelay: true
odom1_differential: false
odom1_relative: false


# GPS setup
# odom2: /odometry/gps
# odom2_config: [ true,  true,  false,
#                 false, false, false,
#                 false, false, false,
#                 false, false, false,
#                 false, false, false  ]
# odom2_queue_size: 10
# odom2_nodelay: true
# odom2_differential: true # Set to true due to x_pos, y_pos overlap with /odometry/encoder
# odom2_relative: false

# IMU setup
imu0: /imu/data
imu0_config: [ false, false, false,
               false, false, true,
               false, false, false,
               false, false, true,
               true,  true,  false  ] # y_accel set to true as robot is holonomic
imu0_queue_size: 10
imu0_nodelay: true
imu0_differential: false
imu0_relative: false

# AMCL setup IS THIS NEEDED???
# pose0: amcl_pose
# CHECK THE MATRIX BELOW!!!
# pose0_config: [ true,  true,  false,
#                 false, false, true,
#                 false, false, false,
#                 false, false, false,
#                 false, false, false  ]
# pose0_differential: false
# pose0_queue_size: 10
# pose0_nodelay: false
# pose0_differential: false
# pose0_relative: false


# Process noise covariance matrix - represents the noise we add to the total error after each prediction step
# Tuning - if variable converges slowly, increase the respective diagonal value (increases filter trust in measurement)
# Order - x, y, z, roll, pitch, yaw, x_vel, y_vel, z_vel, roll_vel, pitch_vel, yaw_vel, x_accel, y_accel, z_accel

process_noise_covariance: [ 0.05, 0,    0,    0,    0,    0,    0,     0,     0,    0,    0,    0,    0,    0,    0,
                            0,    0.05, 0,    0,    0,    0,    0,     0,     0,    0,    0,    0,    0,    0,    0,
                            0,    0,    0.06, 0,    0,    0,    0,     0,     0,    0,    0,    0,    0,    0,    0,
                            0,    0,    0,    0.03, 0,    0,    0,     0,     0,    0,    0,    0,    0,    0,    0,
                            0,    0,    0,    0,    0.03, 0,    0,     0,     0,    0,    0,    0,    0,    0,    0,
                            0,    0,    0,    0,    0,    0.06, 0,     0,     0,    0,    0,    0,    0,    0,    0,
                            0,    0,    0,    0,    0,    0,    0.025, 0,     0,    0,    0,    0,    0,    0,    0,
                            0,    0,    0,    0,    0,    0,    0,     0.025, 0,    0,    0,    0,    0,    0,    0,
                            0,    0,    0,    0,    0,    0,    0,     0,     0.04, 0,    0,    0,    0,    0,    0,
                            0,    0,    0,    0,    0,    0,    0,     0,     0,    0.01, 0,    0,    0,    0,    0,
                            0,    0,    0,    0,    0,    0,    0,     0,     0,    0,    0.01, 0,    0,    0,    0,
                            0,    0,    0,    0,    0,    0,    0,     0,     0,    0,    0,    0.02, 0,    0,    0,
                            0,    0,    0,    0,    0,    0,    0,     0,     0,    0,    0,    0,    0.01, 0,    0,
                            0,    0,    0,    0,    0,    0,    0,     0,     0,    0,    0,    0,    0,    0.01, 0,
                            0,    0,    0,    0,    0,    0,    0,     0,     0,    0,    0,    0,    0,    0,    0.015 ]

# This represents the initial value for the state estimate error covariance matrix. Setting a diagonal value (variance)
# to a large value will result in rapid convergence for initial measurements of the variable in question. Users should
# take care not to use large values for variables that will not be measured directly.

initial_estimate_covariance: [ 1e-9, 0,    0,    0,    0,    0,    0,    0,    0,    0,     0,     0,     0,    0,    0,
                               0,    1e-9, 0,    0,    0,    0,    0,    0,    0,    0,     0,     0,     0,    0,    0,
                               0,    0,    1e-9, 0,    0,    0,    0,    0,    0,    0,     0,     0,     0,    0,    0,
                               0,    0,    0,    1e-9, 0,    0,    0,    0,    0,    0,     0,     0,     0,    0,    0,
                               0,    0,    0,    0,    1e-9, 0,    0,    0,    0,    0,     0,     0,     0,    0,    0,
                               0,    0,    0,    0,    0,    1e-9, 0,    0,    0,    0,     0,     0,     0,    0,    0,
                               0,    0,    0,    0,    0,    0,    1e-9, 0,    0,    0,     0,     0,     0,    0,    0,
                               0,    0,    0,    0,    0,    0,    0,    1e-9, 0,    0,     0,     0,     0,    0,    0,
                               0,    0,    0,    0,    0,    0,    0,    0,    1e-9, 0,     0,     0,     0,    0,    0,
                               0,    0,    0,    0,    0,    0,    0,    0,    0,    1e-9,  0,     0,     0,    0,    0,
                               0,    0,    0,    0,    0,    0,    0,    0,    0,    0,     1e-9,  0,     0,    0,    0,
                               0,    0,    0,    0,    0,    0,    0,    0,    0,    0,     0,     1e-9,  0,    0,    0,
                               0,    0,    0,    0,    0,    0,    0,    0,    0,    0,     0,     0,     1e-9, 0,    0,
                               0,    0,    0,    0,    0,    0,    0,    0,    0,    0,     0,     0,     0,    1e-9, 0,
                               0,    0,    0,    0,    0,    0,    0,    0,    0,    0,     0,     0,     0,    0,    1e-9 ]